import{r as I,g as k}from"./index-aaf730df.js";const T=e=>{let t;const r=new Set,s=(S,f)=>{const l=typeof S=="function"?S(t):S;if(!Object.is(l,t)){const m=t;t=f??typeof l!="object"?l:Object.assign({},t,l),r.forEach(y=>y(t,m))}},n=()=>t,d={setState:s,getState:n,subscribe:S=>(r.add(S),()=>r.delete(S)),destroy:()=>{r.clear()}};return t=e(s,n,d),d},F=e=>e?T(e):T;var A={exports:{}},P={},C={exports:{}},U={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var g=I;function L(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var N=typeof Object.is=="function"?Object.is:L,M=g.useState,z=g.useEffect,J=g.useLayoutEffect,H=g.useDebugValue;function W(e,t){var r=t(),s=M({inst:{value:r,getSnapshot:t}}),n=s[0].inst,o=s[1];return J(function(){n.value=r,n.getSnapshot=t,_(n)&&o({inst:n})},[e,r,t]),z(function(){return _(n)&&o({inst:n}),e(function(){_(n)&&o({inst:n})})},[e]),H(r),r}function _(e){var t=e.getSnapshot;e=e.value;try{var r=t();return!N(e,r)}catch{return!0}}function $(e,t){return t()}var B=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?$:W;U.useSyncExternalStore=g.useSyncExternalStore!==void 0?g.useSyncExternalStore:B;C.exports=U;var q=C.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var D=I,V=q;function X(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var G=typeof Object.is=="function"?Object.is:X,K=V.useSyncExternalStore,Q=D.useRef,Y=D.useEffect,Z=D.useMemo,ee=D.useDebugValue;P.useSyncExternalStoreWithSelector=function(e,t,r,s,n){var o=Q(null);if(o.current===null){var p={hasValue:!1,value:null};o.current=p}else p=o.current;o=Z(function(){function S(v){if(!f){if(f=!0,l=v,v=s(v),n!==void 0&&p.hasValue){var h=p.value;if(n(h,v))return m=h}return m=v}if(h=m,G(l,v))return h;var i=s(v);return n!==void 0&&n(h,i)?h:(l=v,m=i)}var f=!1,l,m,y=r===void 0?null:r;return[function(){return S(t())},y===null?void 0:function(){return S(y())}]},[t,r,s,n]);var d=K(e,o[0],o[1]);return Y(function(){p.hasValue=!0,p.value=d},[d]),ee(d),d};A.exports=P;var te=A.exports;const ne=k(te),{useSyncExternalStoreWithSelector:re}=ne;function oe(e,t=e.getState,r){const s=re(e.subscribe,e.getState,e.getServerState||e.getState,t,r);return I.useDebugValue(s),s}const x=e=>{const t=typeof e=="function"?F(e):e,r=(s,n)=>oe(t,s,n);return Object.assign(r,t),r},se=e=>e?x(e):x,O=new Map,b=e=>{const t=O.get(e);return t?Object.fromEntries(Object.entries(t.stores).map(([r,s])=>[r,s.getState()])):{}},ie=(e,t,r)=>{if(e===void 0)return{type:"untracked",connection:t.connect(r)};const s=O.get(r.name);if(s)return{type:"tracked",store:e,...s};const n={connection:t.connect(r),stores:{}};return O.set(r.name,n),{type:"tracked",store:e,...n}},ae=(e,t={})=>(r,s,n)=>{const{enabled:o,anonymousActionType:p,store:d,...S}=t;let f;try{f=(o??!1)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!f)return e(r,s,n);const{connection:l,...m}=ie(d,f,S);let y=!0;n.setState=(i,u,c)=>{const a=r(i,u);if(!y)return a;const E=c===void 0?{type:p||"anonymous"}:typeof c=="string"?{type:c}:c;return d===void 0?(l==null||l.send(E,s()),a):(l==null||l.send({...E,type:`${d}/${E.type}`},{...b(S.name),[d]:n.getState()}),a)};const v=(...i)=>{const u=y;y=!1,r(...i),y=u},h=e(n.setState,s,n);if(m.type==="untracked"?l==null||l.init(h):(m.stores[m.store]=n,l==null||l.init(Object.fromEntries(Object.entries(m.stores).map(([i,u])=>[i,i===m.store?h:u.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){let i=!1;const u=n.dispatch;n.dispatch=(...c)=>{u(...c)}}return l.subscribe(i=>{var u;switch(i.type){case"ACTION":if(typeof i.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return w(i.payload,c=>{if(c.type==="__setState"){if(d===void 0){v(c.state);return}Object.keys(c.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const a=c.state[d];if(a==null)return;JSON.stringify(n.getState())!==JSON.stringify(a)&&v(a);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(c)});case"DISPATCH":switch(i.payload.type){case"RESET":return v(h),d===void 0?l==null?void 0:l.init(n.getState()):l==null?void 0:l.init(b(S.name));case"COMMIT":if(d===void 0){l==null||l.init(n.getState());return}return l==null?void 0:l.init(b(S.name));case"ROLLBACK":return w(i.state,c=>{if(d===void 0){v(c),l==null||l.init(n.getState());return}v(c[d]),l==null||l.init(b(S.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return w(i.state,c=>{if(d===void 0){v(c);return}JSON.stringify(n.getState())!==JSON.stringify(c[d])&&v(c[d])});case"IMPORT_STATE":{const{nextLiftedState:c}=i.payload,a=(u=c.computedStates.slice(-1)[0])==null?void 0:u.state;if(!a)return;v(d===void 0?a:a[d]),l==null||l.send(null,c);return}case"PAUSE_RECORDING":return y=!y}return}}),h},ue=ae,w=(e,t)=>{let r;try{r=JSON.parse(e)}catch(s){console.error("[zustand devtools middleware] Could not parse the received json",s)}r!==void 0&&t(r)};function j(e,t){let r;try{r=e()}catch{return}return{getItem:n=>{var o;const p=S=>S===null?null:JSON.parse(S,t==null?void 0:t.reviver),d=(o=r.getItem(n))!=null?o:null;return d instanceof Promise?d.then(p):p(d)},setItem:(n,o)=>r.setItem(n,JSON.stringify(o,t==null?void 0:t.replacer)),removeItem:n=>r.removeItem(n)}}const R=e=>t=>{try{const r=e(t);return r instanceof Promise?r:{then(s){return R(s)(r)},catch(s){return this}}}catch(r){return{then(s){return this},catch(s){return R(s)(r)}}}},ce=(e,t)=>(r,s,n)=>{let o={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:u=>u,version:0,merge:(u,c)=>({...c,...u}),...t},p=!1;const d=new Set,S=new Set;let f;try{f=o.getStorage()}catch{}if(!f)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),r(...u)},s,n);const l=R(o.serialize),m=()=>{const u=o.partialize({...s()});let c;const a=l({state:u,version:o.version}).then(E=>f.setItem(o.name,E)).catch(E=>{c=E});if(c)throw c;return a},y=n.setState;n.setState=(u,c)=>{y(u,c),m()};const v=e((...u)=>{r(...u),m()},s,n);let h;const i=()=>{var u;if(!f)return;p=!1,d.forEach(a=>a(s()));const c=((u=o.onRehydrateStorage)==null?void 0:u.call(o,s()))||void 0;return R(f.getItem.bind(f))(o.name).then(a=>{if(a)return o.deserialize(a)}).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==o.version){if(o.migrate)return o.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var E;return h=o.merge(a,(E=s())!=null?E:v),r(h,!0),m()}).then(()=>{c==null||c(h,void 0),p=!0,S.forEach(a=>a(h))}).catch(a=>{c==null||c(void 0,a)})};return n.persist={setOptions:u=>{o={...o,...u},u.getStorage&&(f=u.getStorage())},clearStorage:()=>{f==null||f.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>i(),hasHydrated:()=>p,onHydrate:u=>(d.add(u),()=>{d.delete(u)}),onFinishHydration:u=>(S.add(u),()=>{S.delete(u)})},i(),h||v},le=(e,t)=>(r,s,n)=>{let o={storage:j(()=>localStorage),partialize:i=>i,version:0,merge:(i,u)=>({...u,...i}),...t},p=!1;const d=new Set,S=new Set;let f=o.storage;if(!f)return e((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),r(...i)},s,n);const l=()=>{const i=o.partialize({...s()});return f.setItem(o.name,{state:i,version:o.version})},m=n.setState;n.setState=(i,u)=>{m(i,u),l()};const y=e((...i)=>{r(...i),l()},s,n);let v;const h=()=>{var i,u;if(!f)return;p=!1,d.forEach(a=>{var E;return a((E=s())!=null?E:y)});const c=((u=o.onRehydrateStorage)==null?void 0:u.call(o,(i=s())!=null?i:y))||void 0;return R(f.getItem.bind(f))(o.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==o.version){if(o.migrate)return o.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var E;return v=o.merge(a,(E=s())!=null?E:y),r(v,!0),l()}).then(()=>{c==null||c(v,void 0),v=s(),p=!0,S.forEach(a=>a(v))}).catch(a=>{c==null||c(void 0,a)})};return n.persist={setOptions:i=>{o={...o,...i},i.storage&&(f=i.storage)},clearStorage:()=>{f==null||f.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>h(),hasHydrated:()=>p,onHydrate:i=>(d.add(i),()=>{d.delete(i)}),onFinishHydration:i=>(S.add(i),()=>{S.delete(i)})},o.skipHydration||h(),v||y},de=(e,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?ce(e,t):le(e,t),fe=de,ve=e=>({user:null,token:"",setUser:({token:t,user:r})=>e({token:t,user:r}),removeUser:()=>e({user:null})}),Se=e=>({theme:"light",isDark:!1,setTheme:t=>e(()=>({theme:t,isDark:t==="dark"}))}),he=se()(ue(fe((...e)=>({...Se(...e),...ve(...e)}),{name:"bound-persisted-store",storage:j(()=>localStorage)})));export{he as u};
